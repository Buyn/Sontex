* backlog sprint v1 2025-03-19
** DONE all fichess to back log
CLOSED: [2025-03-17 Mon 16:23]
*** всё из тз
разбить всё на туду
*** BuYn Max, [17.03.2025 10:55]
***** 4
****** отсутствие чек бокса
****** 4
значение не берётся из экселя не прикаких условиях.
всегда используется значение из этого поля
и это значение разница между стало было.
при отсутствии значение расчет останавливается с ошибкой.
и оповещение в лог.
поле не позволит ввести не цифровое значение. И значение меньше нуля.
возможные оповещения и проверки
"Ошибка в поле домового, значение счетчика отсутствует"
"Ошибка в поле домового, значение счетчика должно быть больше нуля"
****** 5-6
******* принцип работы программы
она выполняется в один проход. данные предварительно считываются из файлов или файла данных в момент нажатия кнопки 2.
кнопка 9 позволяет произвести повторное считывание дата файла.
по нажатию кнопки 10, данные из полей отправляются для расчёта.
******* она может брать данные
из ексель файла. а может из файлов данных
если файл данных отсутствует или возникла ошибка его считывание.
значения полей установлены на столбцы эксель файла.
******* 7 кнопка обновить
кнопка 7 позволяет произвести повторное считывание дата файла.
возможная результаты,
(если файлов больше одного то сообщение повторяется для каждого и файлов)
в случае успеха, "Файл (имя и путь к файлу) обновлён успешно"
ошибка,
"Файл (имя и путь к файлу) не найден"
"Файл (имя и путь к файлу) ошибка при считывании"
такие же результаты будут при первичном выборе файлов, через кнопку 2.

******* принципа работы программы при предварительном считывание дата файлов.
в список добавляются имена из первой ячейки следующих колонок дата файла.
Readout date
Historic date - 1-n
где n это значение последней ячейки с заполненным значением в столбце Historic date - n
при запуски программы на расчёт, будут использоваться соответствующие выбранным столбцы.
Heating units totalizer для Readout date
и
Historic value 1-n для Historic date - 1-n

***** 9-8
****** отсутствие чек бокса
значения по умолчанию выставлены как 0.
значения представлены в виде целых чисел и представляют из себя %. при расчетах будут преобразованы в коэффиценты(x/100).
***** 10 пункт без изменений
***** 11-12
мне нужны адреса сайтов куда должны вести баннеры

BuYn Max, [17.03.2025 11:03]
1 - значение по умолчанию
2-3 - Значения для выбора столбцов екселя R или S. являются значения по умолчанию и доступны при отсутствии дата файла.
4 - значение первого значения колонки Readout date из дата файла. При выборе будет использовано значение из колонки Heating units totalizer
5 - значени первого значения колонки Historic date - 1 из дата файла. При выборе будет использовано значение из колонки Historic value 1 
остальные значения подобны 5 но отличаются последней цифрой 1-100
*** 
значение не берётся из экселя не прикаких условиях.
всегда используется значение из этого поля
и это значение разница между стало было.
при отсутствии значение расчет останавливается с ошибкой.
и оповещение в лог.
поле не позволит ввести не цифровое значение. И значение меньше нуля.
возможные оповещения и проверки
"Ошибка в поле домового, значение счетчика отсутствует"
"Ошибка в поле домового, значение счетчика должно быть больше нуля"
*** 
** DONE подготовка нового стейджа
CLOSED: [2025-03-19 Wed 09:39]
*** Лог фаил
*** офрмить новый стейдж орга
** DONE открыть вызов функций винда из маина
CLOSED: [2025-03-20 Thu 11:23]
*** Вопрос
как вызваетя расчетё из кноаки
и как туда передаются все параметры
*** результат
внести понятое в лог или орг
** DONE открыть написаную считывания rvl
CLOSED: [2025-04-05 Sat 12:34]
*** Вопрос
скопировать всё для начало в сандбокс
*** что?
считывается целеком в дф
[[file:~/Dev/Python/Sontex/Src/main.py::def load_rlv(filename):]]
и потом передается для обработки
[[file:~/Dev/Python/Sontex/Src/main.py::def update_counters(app_list, counters_list, df_csv, data_i = 1):]]
который обнаружив что каунтер упоминается в списке апартамента
вызывает у этого апартамента функцию обновления
[[file:~/Dev/Python/Sontex/Src/main.py::r = app_list\[i\].update_allvalues1_by_id(df_csv, name_value, name_date)]]
из
[[file:~/Dev/Python/Sontex/Src/appart_values.py::def update_allvalues1_by_id(self, df, name_value, name_date=None):]]
*** как
import pandas as pd
df = pd.read_csv(filename ,
								encoding = gv_rlv_encoding,
								header = gv_rlv_header,
								sep = gv_rlv_sep,
									index_col = gv_rlv_index_col)

counter.value1 = int(df.loc[ser_id , name_value])
name_value имя столбца
ser_id посуте унивальнаое название строки и втоже время АЙДИ
это особеность как мы открываем рвл
видемо нужно посмотреть как мы считываем для экселя как особенность

r = self._df.iloc[self._line, row]
row это колум перепутано
*** список колонок
Readout date 
Heating units totalizer

Historic value 1 
Historic date - 1 
*** попробывать сделть в сендбоксе
**** функцию считвания одной яцейки
**** фукцию считывания всех
**** переменную
** VERIFY расписать предпологаемую структуру програмы
*** DONE Возможный принцип работы
CLOSED: [2025-03-29 Sat 10:57]
**** DONE 01
CLOSED: [2025-03-29 Sat 10:57]
***** загружается дф
***** популизируется апп
[[file:~/Dev/Python/Sontex/Src/main.py::def populate_apps(df):]]

***** апп пополяется значениями
****** отдельная функция для каждой колонки
r = app_list[i].update_allvalues1_by_id(df_csv,  name_value, name_date)
****** замена имени столбца
    df.iloc[gl_ferst_app_row - 1, gl_column_home_counter_value1] = "показники на " + ";".join(udate_data)
****** функция заполнения домашнего счёчика
        r = set_home_counter(df, last_app_line, _home_count)
***** DONE формирование нового дф
CLOSED: [2025-03-29 Sat 10:57]
****** DONE как?
CLOSED: [2025-03-29 Sat 10:57]
******* найти где мы заполняем блок новых цифр в эксель
есть шанс при втором пополнении туда передедаётся эксесель
    # TODO: remove duble populate_apps
    app_list, couters_list = populate_apps(df) 
[[file:~/Dev/Python/Sontex/Src/main.py::app_list, couters_list = populate_apps(df)]]

основная работа происходит в 
        app = Appart_values(df, app_line)
[[file:~/Dev/Python/Sontex/Src/main.py::app = Appart_values(df, app_line)
 app_line = app.next_app_line]]

 и как минимум тут происходит запись в ексель
[[file:~/Dev/Python/Sontex/Src/appart_values.py::def set_to_report(self, df, column, value):]]

второй сет валуе присутвует в коунтере
[[file:~/Dev/Python/Sontex/Src/counter_values.py::def set_value(self, row, name, value):]]
******* название сет 2 репорт как бы говорит
само за себя
[[file:~/Dev/Python/Sontex/Src/appart_values.py::def set_to_report(self, df, column, value):]]
довай копать суда
******* похоже
я его написал современем меняя начальную идею из-за появления необходимости считывать дополнительный фаил
чтоб как бы было

def set_to_report(self, df, column, value): 
		df.iloc[self._start_line, column] = value

оно для каждого видемо апартамент ане для счёчика знает его строку		
и нужно только укозать колонку
******* DONE вопросы
CLOSED: [2025-03-29 Sat 10:57]
******** CANCELED что такое старт лаин как это согласуется с сёчечиками
CLOSED: [2025-03-28 Fri 16:55]
******** CANCELED откуда вызвается эта функция
CLOSED: [2025-03-28 Fri 16:55]
******** где мы ещё производим запись в ячейку
******* CANCELED Видемо есдинственное место где мы заполняем начальный дф
CLOSED: [2025-03-28 Fri 16:55]
нефига мы так заполняли первый отчёт но так болше уже не делаем - поздровляю!!!
[[file:~/Dev/Python/Sontex/Src/main.py::def set_to_report(df, app_list):]]
с помошью той функции
тамже мы заполняем и остольные листы
ночальный дф мы заполная уже при формировании отчёта просто для галочки
поскольку весь общёт происходит на основе нащего предстовления о значениях в представлениея листа апартаментов и списка в каждом его счёчиков
конкретно заполнение всех счёчиков одного апа происходит следушим путём
******* видемо даные в колонки счёчиков записывает обект счёчик
[[file:~/Dev/Python/Sontex/Src/counter_values.py::def set_value1(self, value):]]

есть функция для записи в первую колонку но нет для записи во вторую
******* а запись из обекта апартаментов
через
[[file:~/Dev/Python/Sontex/Src/appart_values.py::def update_allvalues1_by_id(self, df, name_value, name_date=None):]]
который соответствено записывает только одно значание для всех коунтеров этого апартамента
******* который вызивается из мейна в апдейте
[[file:~/Dev/Python/Sontex/Src/main.py::def update_counters(app_list, counters_list, df_csv, data_i = 1):]]

что соответвенно перебевая все апартаменты в каждом вызвает обновление дефа
[[file:~/Dev/Python/Sontex/Src/main.py::r = app_list\[i\].update_allvalues1_by_id(df_csv, name_value, name_date)]]

приэтом получается очень запутано негде начальный дф не передаётся передаётся дф_откуда берутся данные
а начальный известен соунтеру! он прописане в его обекте каждом(без понятия как это улучшить, беда смешивания функционалки и обектного - получислось очень грязно)
таким образом апартамент вызвается для поиска своих значений в столбце переданого рвл.
И нойдя нужное вызывает такой счёчик для изменения его вго значенив в первом столбце начального дф.
****** DONE Изменить логику
CLOSED: [2025-03-29 Sat 10:57]
******* DONE учивать столбец изменений
CLOSED: [2025-03-29 Sat 10:57]
Мы не учитываем столбец в котором нужно менять значение
теперь при смене значения нужно зарание понять в каком столбце нужно поместить новое значение.
Вроде всё также но логичней сделать единую функцию замены столбцов
Или две почти идентичные функции, но зато без проверок
они вроде не чем не отличаются кроме значения в пареметре столбца
видемо там может быть только булево значение столбец в экселе
если R or S то выбирается глобальная переменная и передаётся фунуции в качестве параметра
и функция имеет универсальнвц вид
такая уже есть в счёчиках
и нужно сделать её обёртку для апартаментов
и таким образом расчитываем нужное значение колонки
и передаём её апартаменту а он прогоняет и передаёт это значение всем её счёсикам
******* DONE вытекает проверка на изменения
CLOSED: [2025-03-29 Sat 10:57]
для каждой ячейки интерфейса выбора столбцов - решаем
если выбраны столбец экселя не менять нечего логично что значение пустая строка или ноль
если выбраны другие начинаем разбирать, для каждой ячейки по отдельности.
что означает что может быть универсальная функция
которую мы запускаем дважды для каждой ячейки(передовая внеё 2 параметра)имя столбца, имея ячеёки
имея ячеёки для имён ячеек есть значение их номера столбца в экселе. Состояшая из формулы подсчёта или просто соответсвия.
имя столбца перебирается в списке пресчитывания.и выесняется индекс. и на основе этого индекса выбираем имя колонки в рвл файле
после чего
видемо отдельные функции
для считывание значений из произвольной колонки
и затем перезаписи значения в произвольной колонке(хоть и ограниченой всего двумя в исользовании)
после этого проце
******* DONE функция разбора более одного файла
CLOSED: [2025-03-29 Sat 09:34]
дополняем переменые соответсвий
******* DONE функцмя обработки индексов
CLOSED: [2025-03-29 Sat 10:55]
при использовании интексов должна делатся пометка
какие индексы были найдены а какие небыли обнавлены для отдельного файла
и выводить сравнительную статистику для всех файлов, перекрёсно сравнивая все ли индексы были найдены или остались не обнавлёные.
основная цель сделать список индексов которые небыли обнавлены по присутствуют в экселе. для этого есть удобный список всех индексов
****** сылка
***** заполнения апп с нуля
***** расчёт показателей
***** при записи уже есть готовая страница
***** -
***** +
***** todo
найти где мы заполняем блок новых цифр в эксель
**** CANCELED имеет ли это вообше смысл
CLOSED: [2025-03-28 Fri 18:40]
может начальный вариант лучше
мы заполняем значения виртуальных обектов и работаем сними и нам насрать откуда они взялись
а потом просто скидываем это в конечный фаил отч1та то на чём всё расчитывалось
таким образом упрошая проша и разделяя процесы как отдельные несвязаные модули
**** размышления

похоже нет возможности сделать правельный дф пополнив ексельный.
поскольку в csv содержится только часть индексов в произвольном порядке.
как решено - дф переводится в во внутренюю структуру из двух переменых
app_list список апартаментов
counters_list и отдельно дублированый с писок номеров счёчиков

пути решения
- оставить и улучшить что есть
	убрать двойную популяцию
	убрать ошибки не найденых значений если они в разных csv
- пытатся заменять в дф
- запонив вернуть сформировать новый дф
	поскольку мы его там и так потому будем формировать
- переписать снуля
	поскольку решение которое есть учитывает только один столбец
*** принцип работы
**** переписать цикла расчёт гуевый
***** перенся всё орг фаил
***** перенеся его в гуй
**** функция пресчитывания значения в рвл rvl
***** сделать вначале для одного файла
***** второй фаил
в причтении не участвует
колонки внем будут использоватся теже что выбраны в первом
как и в начальной програме
***** CANCELED потом понять как прикрутить второй
CLOSED: [2025-03-30 Sun 08:48]
нужно сделать такойже список
потому она не чем не отличается от первой функции
но потом она должна перебрать каждое значение из

***** функция разбора более одного файла
просто откидывает путь после точки запитой
***** функция персчитывания считывания rvl
получаем две глобальные вектора
имя столбца и значение первой яцейки
потом заня номер значения можно получить имя

**** функция сполучения rvl с интерфейсом
***** Считывание происходит при выборе файла
или отдельно по нажатию кнопки интерфейса
***** это экспоз функция
получает как праметр путь к файлу или файлам
на выходе даёт два списка
один из которых возврашает в жс
это список из сток с датами он напрямую обновляет поле выбора колонок
есть соответсвие индекса этого списка со списком названия колонок
потом мы получив имя найдем его индек и этот индекс это индекс с именем нужной колонки
***** функция в жс
просто запускает експоз функцию
ждет её завершения и 
обновляет список элементов в ячейке выбора колонки
**** при нажатии кнопки расчёта
происходит несколь другие действия чем сейчас
**** функция в экспоз передаёт словарь
***** значений вместо списка переменых
***** два из новых параметров это имя колонки
он должен соответсвовать значению в списке переданых переменых
экспоз фукцией
***** для каждой колонки указано её имя
тоесть мы передаём две колонки в словаре со значением строка
тоесть поскольку это слово
и таким образом популяция происходит дважды
возможно для каждого файла с этой колонкой
и потом повторно для каждой из колонок
**** поменять в цикле считывание со славаря
все параметры заносятся в словарь
если еть параметр если нет нил
может это разбить на функции
**** определение имён колонок
***** поиск соответсвий
в векторе списка дат ишется переданая дата и определяется её индекс
по этому индексу возврашается имяколонки из вектора колонок
**** функция изменейн в обект коунте
***** вариант всегда использовать обшую функцию
просто будет приходить указание столбца для записи
***** настроена принимать и колонку
помойму сейчас так и принимает просто ипользуется со значанием
***** дополнительная функция записи во вторую колонку
токаяже как первая простосто указа вторая колонка
есть тоже имя только цифра2
**** функция изменейн в обект апартаментс
***** запись всех коунтеров в нужную колонку
***** тоесть новая функция общего действия
тоесть мы передаем имя колонки
и она шпарит нужную наденое ИД из рвл в нужную указанаю колонку
так как это работало с одной колонкой
но для записи использует уневерсальную функцию
**** новая функция популяции списка
***** как оригинальная но
получает указание в какой столбец записовать
и прогоняется дважды для каждой колонки
***** учивать столбец изменений
Мы не учитываем столбец в котором нужно менять значение
теперь при смене значения нужно зарание понять в каком столбце нужно поместить новое значение.
Вроде всё также но логичней сделать единую функцию замены столбцов
Или две почти идентичные функции, но зато без проверок
они вроде не чем не отличаются кроме значения в пареметре столбца
видемо там может быть только булево значение столбец в экселе
если R or S то выбирается глобальная переменная и передаётся фунуции в качестве параметра
и функция имеет универсальнвц вид
такая уже есть в счёчиках
и нужно сделать её обёртку для апартаментов
и таким образом расчитываем нужное значение колонки
и передаём её апартаменту а он прогоняет и передаёт это значение всем её счёсикам
***** вытекает проверка на изменения
для каждой ячейки интерфейса выбора столбцов - решаем
если выбраны столбец экселя не менять нечего логично что значение пустая строка или ноль
если выбраны другие начинаем разбирать, для каждой ячейки по отдельности.
что означает что может быть универсальная функция
которую мы запускаем дважды для каждой ячейки(передовая внеё 2 параметра)имя столбца, имея ячеёки
имея ячеёки для имён ячеек есть значение их номера столбца в экселе. Состояшая из формулы подсчёта или просто соответсвия.
имя столбца перебирается в списке пресчитывания.и выесняется индекс. и на основе этого индекса выбираем имя колонки в рвл файле
после чего
видемо отдельные функции
для считывание значений из произвольной колонки
и затем перезаписи значения в произвольной колонке(хоть и ограниченой всего двумя в исользовании)
после этого проце
***** функция не предпологает
изменений последовательности столбцов расчёт
он предпологает варианты либо столбци экселя
либо заполнение их произвольно значениями из рвл
***** CANCELED на основе разбора параметра
CLOSED: [2025-03-29 Sat 10:58]
либо не делать не чего
либо поменять местами столбци
либо заполнить столбци значениями из рвл
таким путём в расчёт уже сразу подаётся правельный эксль
без необходимости множественног его заполнения
**** функцмя обработки индексов
при использовании интексов должна делатся пометка
какие индексы были найдены а какие небыли обнавлены для отдельного файла
и выводить сравнительную статистику для всех файлов, перекрёсно сравнивая все ли индексы были найдены или остались не обнавлёные.
основная цель сделать список индексов которые небыли обнавлены по присутствуют в экселе. для этого есть удобный список всех индексов
*** переписать всё в орг
переписать в маин орг описания работы заполнения списка
уж очень он замысловат и нужны коментарии
** NEXT функция считывания 1 значания в списке колонок
*** DONE прогнать как сендбокс
CLOSED: [2025-04-05 Sat 12:49]
*** сделать комит
*** TODO Прогнать тесты
**** сделать shell script
использует вренворемент
**** запустить
**** сделать вариант из запуска из орг
**** r
убедится что всё работает как есть
*** сделать интеграционый тест
**** Сделать тест в орге
***** взять за онову какойто готовый
***** прогнать с какимто просто инетом
**** запускает гуйкалк с параметрами
**** считывает получившийся отпут
**** принять всё как есть за норму
**** сменить значения в дф
**** убедится что значения стали не норм
*** перенести файл в орг
*** собрать 
*** прогнать тесты снова
*** перенсти запуск на winmain
*** прогнать тесты снова
*** написать функцию
**** получает имя файла и лист именё колонок
**** возврашает
лист первых заначений в этих колонках
** функция пре считывания даных из дата файла
*** прописать в интерфейсе
*** считывание дата файла
кнопка 7 позволяет произвести повторное считывание дата файла.
возможная результаты,
(если файлов больше одного то сообщение повторяется для каждого и файлов)
в случае успеха, "Файл (имя и путь к файлу) обновлён успешно"
ошибка,
"Файл (имя и путь к файлу) не найден"
"Файл (имя и путь к файлу) ошибка при считывании"
такие же результаты будут при первичном выборе файлов, через кнопку 2.
*** взять за основу код считывания столбцов
*** глобальная переменная соответсвий
текстов строк и значений соответсвия колонок данных
*** список добавляются имена
в список добавляются имена из первой ячейки следующих колонок дата файла.
Readout date
Historic date - 1-n
где n это значение последней ячейки с заполненным значением в столбце Historic date - n
при запуски программы на расчёт, будут использоваться соответствующие выбранным столбцы.
Heating units totalizer для Readout date
и
Historic value 1-n для Historic date - 1-n
** Убедится что мы можем заменять значения кофицентов
** домовой счёчик
*** raw
значение не берётся из экселя не прикаких условиях.
всегда используется значение из этого поля
и это значение разница между стало было.
при отсутствии значение расчет останавливается с ошибкой.
и оповещение в лог.
поле не позволит ввести не цифровое значение. И значение меньше нуля.
возможные оповещения и проверки
"Ошибка в поле домового, значение счетчика отсутствует"
"Ошибка в поле домового, значение счетчика должно быть больше нуля"
*** функция обновления импут экселя
на новые значения счёчика на основе полученого одно значения
** all2org
** логотипы должны вести на сайты компаний
** CANCELED Подготовить следуший спринт
CLOSED: [2025-04-05 Sat 12:41]
*** отметить как Некст этот
*** убрать законченые туду вниз
*** Создать новый спринт раздел в org
*** добавить копию канбан вновый орг
скопиями делами на новй спринт и закончить спринт
[[*tmp bord][tmp bord]]
*** открыть в беклоге туду новый спринт
[[*Новый спринт][Новый спринт]]
*** добавить в гит завершаюший комит
*** замержить с мейном
**** commands 
git checkout main
git merge --no-ff rlv_beta
st
gh 
st

**** orig
che
git merge --no-ff f_encoder_to_old
# git branch -d f_encoder_to_old
st
gh 
st
*** создать новый бранч
git checkout -b exe_beta
git push -u --set-upstream origin exe_beta
^сделать возможным пушь


*** запонить канбан списком дел из беклога
*** отметить как Туду этот
* orgs
** SRC org files
*** main.org
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/DOCs/main.org")
#+end_src
*** sandbox
**** sandbox.org
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/sandbox.org")
#+end_src
**** sandbox.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/sandbox.py")
#+end_src
** Орг лог
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dropbox/Office/Progects/Zmei/Sontex/Org-Log/2024-09-06-Sontex-alfa-log.org")
#+end_src
* data files
** build path
(ranger "/home/buyn/Dev/Python/Sontex/raw-files/")
/home/buyn/Dev/Python/Sontex/raw-files/
** build files 2024-09-11
/home/buyn/Dev/Python/Sontex/raw-files/input.xlsx
/home/buyn/Dev/Python/Sontex/raw-files/output.xlsx
/home/buyn/Dev/Python/Sontex/raw-files/debag_2024.xlsx
** test run
/home/buyn/Dev/Python/Sontex/Src/Data_files/test.xlsx
/home/buyn/Dev/Python/Sontex/Src/Data_files/output.xlsx
* macroses
** calc-all:
#+begin_src emacs-lisp :results output silent
(load-file "~/keymac/calc-all.el")
#+end_src
#+begin_src emacs-lisp :results output silent
(fset 'calc-all
   (kmacro-lambda-form [?\C-u ?\C-c ?*] 0 "%d"))
#+end_src
#+begin_src emacs-lisp :results output silent
(global-set-key (kbd "<f5>") 'calc-all)
#+end_src
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/keymac/calc-all.el")
#+end_src
** convert-ru-point : 
#+begin_src emacs-lisp :results output silent
(load-file "~/keymac/convert-ru-point.el")
#+end_src
#+begin_src emacs-lisp :results output silent
(fset 'convert-ru-point
   (kmacro-lambda-form [?ð ?ð ?J ?F ?, ?r ?.] 0 "%d"))
#+end_src
#+begin_src emacs-lisp :results output silent
(global-set-key (kbd "<f6><f6>") 'convert-ru-point)
#+end_src
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/keymac/convert-ru-point.el")
#+end_src
** functions +-
*** new
#+begin_src emacs-lisp  :results output silent
(defun buyn-org-table-change ( value)
	(org-table-get-field nil (number-to-string (+ value (string-to-number (org-table-get-field))))))

(global-set-key (kbd "<f5>") '(lambda () (interactive)
																(buyn-org-table-change -1)
																(org-table-recalculate)))

(global-set-key (kbd "<f6>") '(lambda () (interactive)
																(buyn-org-table-change 1)
																(org-table-recalculate)))



#+end_src
*** orig
#+begin_src emacs-lisp  :results output silent
(defun my-org-table-change ( value)
	(org-table-get-field nil (number-to-string (+ value (string-to-number (org-table-get-field))))))

(defun my-org-table-decrement ()
  (interactive)
	(my-org-table-change -1))

(defun my-org-table-increment ()
  (interactive)
	(my-org-table-change 1))

(global-set-key (kbd "<f5>") 'my-org-table-decrement)
(global-set-key (kbd "<f6>") 'my-org-table-increment)
#+end_src
*** test 
|   |   |    |    |   |
| 6 | 5 |  0 |  1 |   |
|   |   | 10 |    |   |
|   |   |  3 | -5 | 0 |
|---+---+----+----+---|
|   |   |    |    |   |
|   |   |    |    |   |
|   |   |    |    |   |
|   |   |    |    |   |
|   |   |    |    |   |

* project comands
:PROPERTIES:
:header-args: :tangle no
:END:
** ranger
(ranger "/home/buyn/Dev/Python/Sontex/raw-files/")
** emacs src env actuv
*** eshell
#+begin_src elisp :dir /home/buyn/Dev/Python/Sontex/Src/ :results output silent
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(pyvenv-activate "/home/buyn/Dev/Python/Sontex/Src/sontex-env")
(let (buffer-name-to-close (buffer-name))
				(evil-window-split)
				(eshell)
				(evil-quit)
				(switch-to-buffer-other-frame buffer-name-to-close))
#+end_src
*** comands
python -m unittest
python main.py
python -m main.py
** emacs build env actuv
*** eshell
#+begin_src elisp :dir /home/buyn/Dev/Python/Sontex/build/ :results output silent
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(pyvenv-activate "/home/buyn/Dev/Python/Sontex/build/sontex-env")
(let (buffer-name-to-close (buffer-name))
				(evil-window-split)
				(eshell)
				(evil-quit)
				(switch-to-buffer-other-frame buffer-name-to-close))
#+end_src
*** comands
python -m unittest
python main.py
python -m main.py
** activate build
*** new sh
#+begin_src elisp  :dir /home/buyn/Dev/Python/Sontex/build/
(buyn-shell-start "konsole -e /bin/bash --rcfile <(source sontex-env/bin/activate)")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src
*** source
source sontex-env/bin/activate
cd /home/buyn/Dev/Python/Sontex/Src/
*** run main
python main.py
*** run all tests
python -m unittest
*** buyn-shell-start
(buyn-shell-start "konsole -e /bin/bash --rcfile <(source sontex-env/bin/activate)")
** activate src
*** new sh
#+begin_src elisp  :dir /home/buyn/Dev/Python/Sontex/Src/
(buyn-shell-start "konsole -e /bin/bash --rcfile <(source sontex-env/bin/activate)")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src
*** source
source sontex-env/bin/activate
cd /home/buyn/Dev/Python/Sontex/Src/
*** buyn-shell-start
(buyn-shell-start "konsole -e /bin/bash --rcfile <(source sontex-env/bin/activate)")
*** run all tests
python -m unittest
** run console in sontex activ
#+begin_src elisp :results output silent :dir /home/buyn/Dev/Python/Sontex/Src/
(buyn-shell-start "konsole -e /bin/bash --rcfile <(source sontex-env/bin/activate)")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src
source sontex-env/bin/activate
cd sontex-env
** run in eshell
*** run eshell
#+begin_src elisp :results output silent :dir /home/buyn/Dev/Python/Sontex/Src/
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(let (buffer-name-to-close (buffer-name))
	(evil-window-split)
				(eshell)
				(evil-quit)
				(switch-to-buffer-other-frame buffer-name-to-close))
#+end_src
*** comannds
python main.py
python -m unittest

source sontex-env/bin/activate
cd sontex-env

** save буфер фреймы проекта
#+begin_src emacs-lisp  :results output silent
(use-package burly
 :ensure t
 ;; :config
	)
;; (burly-bookmark-frames "sontex buffers")
(burly-bookmark-frames "buffers LAST SAVE")
(bookmark-save)
#+end_src
** run eshell in org root
clj -M:dev
clojure -m cljs.main --compile my-cljs-project.core --repl
#+begin_src elisp :results output silent
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(let (buffer-name-to-close (buffer-name))
				(evil-window-split)
				(eshell)
				(evil-quit)
				(switch-to-buffer-other-frame buffer-name-to-close))
#+end_src

			;; (execute-kbd-macro "A \C-m")
** run console in sontex
#+begin_src elisp :results output silent :dir /home/buyn/Dev/Python/Sontex/Src/
(buyn-shell-start "konsole")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src
source sontex-env/bin/activate
cd sontex-env
** run console in org root
#+begin_src elisp :results output silent
(buyn-shell-start "konsole")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src

** run console with command
#+begin_src elisp :results output silent
(buyn-shell-start "konsole -e /bin/bash --rcfile <(clj -M:dev)")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src

* 2025-03-19
** version 1.0
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/DOCs/v1_Stage.org")
#+end_src
** Sontex.org
D:\Development\lisp\Dropbox\Office\Progects\Zmei 
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/../Dropbox/Office/Progects/Zmei/Sontex/Sontex.org")
#+end_src

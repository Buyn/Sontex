:PROPERTIES:
:header-args: :tangle no :cmdline arg ; source ../sontex-env/bin/activate
:END:
* Eel files
** index.html
:PROPERTIES:
:header-args: :tangle "../Src/web/index.html" 
:END:
*** file
(find-file-other-frame "../Src/web/index.html")
*** src
**** html open
#+begin_src html
<!DOCTYPE html>  
<html lang="ru">  
#+end_src
**** header
#+begin_src html
<head>  
  <meta charset="UTF-8" />  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />  
  <meta name="viewport" content="width=device-width,  
initial-scale=1.0" />  
  <title>Sontex</title>  

  <link rel="stylesheet" href="dark.css"/>
  <!-- <link rel="stylesheet" href="light.css"/>   -->
  <link rel="stylesheet" href="style.css"/> 
  <script type="text/javascript" src="../eel.js"></script>  
  <script src="./script.js" defer></script>  
</head>  
#+end_src
**** body
***** body open
#+begin_src html
<body>  
#+end_src
***** Sontex title row
#+begin_src html
  <h1>Програма розрахунку</h1>  
  <!-- <div class="random_number"></div> -->
#+end_src
***** Form
****** Form open
#+begin_src html
  <form id="init-form" action="javascript:">
#+end_src
****** экселе фаил
#+begin_src html
    <div class="row" title="

  Відформатований файл EXEL з усіма необхідними показаннями для формування звіту.
  Основний та головний файл необхідний для звітування.
  Якщо не буде задано вихідний файл, то буде перезаписаний цей файл. Що дозволяє формувати новий звіт за результатами формування попереднього.

">
      <button id="exel-btn">Excel файл</button>  
      <!-- <input type="file" hidden id="exel-file" > -->
      <input type="text" class="long" id="exel-input" name="exel">
    </div>
#+end_src
****** показание устройств
#+begin_src html
    <div class="row" title="

  Файл або файли (розділені символом ;) із показаннями пристроїв у форматі .csv або .rlv.
  Замінює показання пристроїв, отримані з файлу Excel. І формує звіт, на основі нових показників пристроїв.

">
      <button id="csv-btn">Показників пристроїв</button>  
      <input id="csv-input" name="csv" type="text" class="long" >
    </div>
#+end_src
      <!-- <input type="file" hidden id="csv-file" > -->

****** фаил отчёта
#+begin_src html
    <div class="row" title="

  Шлях до місця розташування звіту після формування та ім'я сформованого файлу звіту.
  Клітина може залишитися пустою, де кінцевим файлом буде обрано - вхідний. Результат буде оновлено у цьому файлі.

">
      <button id="output-btn">Файл звіту</button>  
      <input type="text" class="long" id="output-input" name="output">
    </div>
#+end_src

****** Обще домовой счёчик
#+begin_src html
    <div class="row" title="
Показник загальнобудинкового лічильника за звітний/розрахунковий період (Гкал)
">
      <label>
Показник загальнобудинкового лічильника за звітний/розрахунковий період (Гкал)
      </label>
      <input id="curr-count" name="curr-count" type="number" step="any" class="short" placeholder="Гкал">
    </div>
#+end_src

****** Розрахунковий період з - по
#+begin_src html
    <div class="row" title="
Розрахунковий період з - по
">
      <label>
Розрахунковий період з-
      </label>
      <select id="prev-date" name="prev-date">
        <option> R col exel </option>
        <option> S col exel </option>
        <option> 26.11.2024 </option>
        <option> 01.11.2024 </option>
        <option> 01.10.2024 </option>
        <option> 01.09.2024 </option>
        <option> 01.08.2024 </option>
        <option> 01.07.2024 </option>
        <option> 01.06.2024 </option>
        <option> 01.05.2024 </option>
        <option> 01.04.2024 </option>
        <option> 01.03.2024 </option>
        <option> 01.02.2024 </option>
        <option> 01.01.2024 </option>
        <option> 01.12.2023 </option>
        <option> 01.11.2023 </option>
        <option> 01.10.2023 </option>
        <option> 01.09.2023 </option>
        <option> 01.08.2023 </option>
        <option> 01.07.2023 </option>
        <option> 01.06.2023 </option>
        <option> 01.05.2023 </option>
        <option> 01.04.2023 </option>
      </select>
      <label>
  по-
      </label>
      <select id="curr-date" name="curr-date">
        <option> S col exel </option>
        <option> R col exel </option>
        <option> 26.11.2024 </option>
        <option> 01.11.2024 </option>
        <option> 01.10.2024 </option>
        <option> 01.09.2024 </option>
        <option> 01.08.2024 </option>
        <option> 01.07.2024 </option>
        <option> 01.06.2024 </option>
        <option> 01.05.2024 </option>
        <option> 01.04.2024 </option>
        <option> 01.03.2024 </option>
        <option> 01.02.2024 </option>
        <option> 01.01.2024 </option>
        <option> 01.12.2023 </option>
        <option> 01.11.2023 </option>
        <option> 01.10.2023 </option>
        <option> 01.09.2023 </option>
        <option> 01.08.2023 </option>
        <option> 01.07.2023 </option>
        <option> 01.06.2023 </option>
        <option> 01.05.2023 </option>
        <option> 01.04.2023 </option>
      </select>
      <button id="reload"> ⤺ <br> ⤻ </button>
    </div>
#+end_src
****** установки кофицентов
#+begin_src html
    <div class="row" title="
Вкажіть коефіцієнт, Враховувати втрати тепла на МЗК та ФСО
значення 0 за відсутності коефіцієнта.
">
      <label>
        Враховувати втрати тепла на МЗК та ФСО
      </label>
      <input id="mzk-cof" name="mzk-cof" type="number" step="any" class="short" placeholder="0">
      <label>
         МЗК,<br>%
      </label>

      <input id="fso-cof" name="fso-cof" type="number" step="any" class="short" placeholder="0">
      <label>
         ФСО,<br>%
      </label>
    </div>
#+end_src
****** сформировать отчёт
#+begin_src html
      <button id="report-btn">Сформувати звіт</button>  
#+end_src
      <!-- <label> -->
      <!--  <input type="checkbox"> ОСББ -->
      <!-- </label> -->
#+begin_src html
    </div>
#+end_src
****** End Form
#+begin_src html
  </form>
#+end_src
***** log
#+begin_src html
    <textarea name="log" id="log" readonly>
      
      Ласкаво просимо! Почнемо програму.

    </textarea>
#+end_src
***** down row
#+begin_src html
    <div class="logos">
      <a href="https://google.com?q=sontex">
        <img src="sontex.png">
      </a>
      <a href="https://google.com?q=antap">
        <img src="antap.png">
      </a>
    </div>
#+end_src
***** CANCELED report-modal
CLOSED: [2025-03-15 Сб 16:51]
<!-- ** report-modal </h1>:  -->

<!-- <a onclick="getFolder()">GetFolder</a> -->
<!--  </form> -->
<!--  <dialog id="report-modal">   -->
<!--      <input type="text" class="long"> -->
<!--  </dialog>  -->

<!--  <button id="genbutton">Get a Random number using Python</button>   -->

***** body close
#+begin_src html
</body>
#+end_src
**** html close
#+begin_src html
</html>  
#+end_src

** script.js
:PROPERTIES:
:header-args: :tangle "../Src/web/script.js" 
:END:
(find-file-other-frame "../Src/web/script.js")
#+begin_src js :results output silent
// * const : 
const initForm = document.getElementById("init-form");
const cookies = document.cookie.split("; ").map(str => str.split("=")).reduce((obj, [key, value]) => ({...obj, [key]:value}), {});

const logArea = document.getElementById("log");

const useCounterBox = initForm["use-count"];
const prevCounter = initForm["prev-count"];
const currCounter = initForm["curr-count"];

const exelBtn = initForm["exel-btn"];
// const exelFile = initForm["exel-file"];
const exelInput = initForm["exel-input"];

const csvBtn = initForm["csv-btn"];
// const csvFile =  initForm["csv-file"];
const csvInput = initForm["csv-input"];
// console.log(document.cookie);

const outputBtn = initForm[  "output-btn"];
// const outputFile = initForm["output-file"];
const outputInput = initForm["output-input"];

const reportBtn = initForm["report-btn"];
// const reportModal = document.getElementById("report-modal");

// * cookies : 
exelInput.value = cookies.exel || "";
csvInput.value = cookies.csv || "";
outputInput.value = cookies.output || "";

// * onchange : 
useCounterBox.onchange = () => {
    prevCounter.disabled = !useCounterBox.checked;
    currCounter.disabled = !useCounterBox.checked;
}

// * onclick : 
exelBtn.onclick = () => getExel(  exelInput,
                                  ["excel files","*.xlsx"],
                                  "Вибрати файл вхідного звіту");

csvBtn.onclick = () => getDBfile( csvInput,
                                  [["csv files", "*.csv"], ["rlv files", "*.rlv"]],
                                  "Обрати файл показників пристроїв .csv або .rlv");

outputBtn.onclick = () => saveAs( outputInput,
                                  ["excel files","*.xlsx"],
                                  "Зберегти звіт як");

reportBtn.onclick = () => start_calc();

refreshLog();
setInterval(refreshLog, 3000);

// * function getExel :
async function getExel(input, filetype, title) {
    var dosya_path = await eel.btn_ask_open_exel_file(input.value, filetype, title)();
    if (dosya_path) {
        console.log(dosya_path);
        input.value = dosya_path;
        document.cookie = input.name + "=" + dosya_path;
        }
    refreshLog();
    }

// * function getDBfile :
async function getDBfile(input, filetype, title) {
    var dosya_path = await eel.btn_ask_open_DBfiles(input.value, filetype, title)();
    if (dosya_path) {
        console.log(dosya_path);
        input.value = dosya_path;
        document.cookie = input.name + "=" + dosya_path;
        }
    refreshLog();
    }

// * function saveAs :
async function saveAs(input, filetype, title) {
    var dosya_path = await eel.btn_asksaveasfile(input.value, filetype, title)();
    if (dosya_path) {
        console.log(dosya_path);
        input.value = dosya_path;
        document.cookie = input.name + "=" + dosya_path;
        }
    refreshLog();
    }

// * function sendToLog :
function sendToLog(text) {
    logArea.value = text + "\n" + logArea.value;
    }
// * function refreshLog :
async function refreshLog() {
    var log_strings= await eel.pull_log()();
    log_strings.reverse();
    log_strings.forEach(string => sendToLog(string));
    }


// * function start_calc() : 
async function start_calc() {
    console.log("statr calc");
    sendToLog(" ");
    sendToLog(" ");
    sendToLog("--------------------------------------------------");
    // sendToLog(new Date().toISOString().replace("T", " ").slice(0,16));
    sendToLog(new Date());
    sendToLog("Почато розрахунок показників");
    document.cookie = exelInput.name + "=" + exelInput.value;
    document.cookie = csvInput.name + "=" + csvInput.value;
    document.cookie = outputInput.name + "=" + outputInput.value;
    const counterValues = useCounterBox.checked && [currCounter.value, prevCounter.value] || null;
    console.log(counterValues);
    var r = await eel.start_calc(exelInput.value, csvInput.value, outputInput.value, counterValues)();
    refreshLog();
    console.log(exelInput.value);
    console.log(csvInput.value);
    console.log(outputInput.value);
    console.log("result of calc =", r);
    refreshLog();
    await pause(2000);
    sendToLog("Розрахунок показників завершився успішно");
    sendToLog("Результат розрахунку збережено у файлі " + outputInput.value);
    refreshLog();
    // sendToLog(new Date().toISOString().replace("T", " ").slice(0,16));
    sendToLog(new Date());
    sendToLog("==================================================");
    sendToLog(" ");
  }
function pause(delay){
    return new Promise(resolve => setTimeout(resolve, delay));
}
#+end_src

** style.css
:PROPERTIES:
:header-args: :tangle "../Src/web/style.css" 
:END:
(find-file-other-frame "../Src/web/style.css")
#+begin_src css :results output silent
h1 {  
/*  color: green;   */
  text-align: center;  
}

.random_number {  
/*  margin: 50px;   */
/*  font-size: 150px;   */
/*  text-align: center;   */
}  

button {
  /* display: block;   */
  /* margin: 0 auto; */
    white-space: nowrap;
    width: 240px;
}  

#reload {
  padding: 1px;
  width: unset;
  line-height: 0.6;
  align-self: center;
  }


#report-btn {
  /* align: center; */
  display: block;
  /* width: max-content; */
  margin: auto;
}

.row {
    display: flex;
    margin-bottom: 10px;
    gap: 5px;
    align-items: center;
    /* justify-content: space-between; */
    /*    margin-right: 50px; */
}

label {
    /* text-align: right; */
    text-align: left;
}

.long {
    width : 75%;
/*    margin-left: auto; */
}
.short {
   width : 10%;
   margin-left: 15px;
}

.logos {
    margin-top: 20px;
    display: flex;
    justify-content: space-between;
}

.logos img {
    height: 100px;
    /* width: 240px; */
}

#+end_src
* SRC files
** global_values
*** global_values.py
**** file
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "../Src/global_values.py")
#+end_src
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/global_values.py")
**** src global_values.py
:PROPERTIES:
:header-args: :tangle ../Src/global_values.py
:END:
***** coments
# * imports : 
# ----------------------------------------------


# ----------------------------------------------
# * vars :
# ----------------------------------------------
***** all
#+begin_src python
# ** GUI:
# *** main window:
# gg_eel_mode = 'electron'
# gg_eel_mode = 'chrome'
# gg_eel_mode = None
# gg_eel_mode = 'edge'
gg_eel_mode = 'chrome'
gg_GUI = True
# gg_GUI = False
# ** .xlsx:
# gv_filename = "Data_files/metod01.xlsx"
gv_output = "Data_files/output.xlsx"
gv_filename = "Data_files/metod01.xlsx"
# sheet_name = "показники"
gv_sheet_name = "квартири, площі"
gv_sheet_report = "report"

# ** .csv:
gv_csv = "Data_files/test.csv"
# кодировка файла
gv_csv_encoding = "cp1252"
# строки с которых начинается имена колонок
gv_csv_header   = 1
# номер колонки от 0 в котором указаны индефикаторы устройств 
gv_csv_index_col= 5
# символ раздилитель используюшийся в файле
gv_csv_sep      = ";"
gv_csv_name_i   = 1
gv_csv_name_date= "Historic date - "
gv_csv_name_value="Historic value - "
# name_text = "Historic date - " + str(gv_csv_name_i)
# name_value = "Historic value - " + str(gv_csv_name_i)

# ** .rlv:
gv_rlv = "Data_files/test.rlv"
# gv_rlv = "Data_files/test.rlv"
# кодировка файла
gv_rlv_encoding = "utf-16le"
# строки с которых начинается имена колонок
gv_rlv_header   = 0
# номер колонки от 0 в котором указаны индефикаторы устройств 
gv_rlv_index_col= 5
# символ раздилитель используюшийся в файле
# gv_rlv_sep      = ";"
gv_rlv_sep      = "\t"
# gv_rlv_sep      = " "
# gv_rlv_sep      = ""
gv_rlv_name_i   = 1
gv_rlv_name_date= "Historic date - "
gv_rlv_name_value="Historic value - "
# name_text = "Historic date - " + str(gv_rlv_name_i)
# name_value = "Historic value - " + str(gv_rlv_name_i)
# ** Kooficeints:
# обсяг тепла на функц. системи = 5% якщо є погодне регулювання в ІТП або 15% якщо не має від
# при значение 0 переменая не используется
gk_Qfun_sys = 0.05
# gk_Qfun_sys = 0
# обсяг тепла на опалення МЗК = 10% від
# при значение 0 переменая не используется
gk_Qmzk = 0.1
# gk_Qmzk = 0
# Мінімальна частка середнього питомого споживання
gk_Qop_min = 0.5
# Обсяг споживання тепла приміщенням без розподілювачів
# k = 2, якщо площа необладнаних приміщень менще 25% та 1,5 якщо більше
qk_k_no_surge_proc    = 0.25
qk_k_no_surge_if_more = 1.5
qk_k_no_surge_if_less = 2
# ** setings:
# количество знаков после запятой для gk_Qop_min переменой
# при повышение точности в этой переменой разница силльно растёт
# False для максимальной точности
# True для
# 3 значения соответствуюшее екселю
gk_Qop_min_after_point = False
# максимальное количество повторений поика нуля
# (повторения циклов распределения)
# 2 для значений близких к exel
gs_recalc_surcharge_times = 200
# печатать шаг на котором найден ноль
gs_recalc_surcharge_print_result = False
# gs_recalc_surcharge_print_result = True
gs_recalc_surcharge_print = False
# gs_recalc_surcharge_print = True
# ** exel coordinats:
# *** "квартири, площі":
gl_app_sum_area_column = 4 # номер колонки (Площа загальна по даним КТЕ)
gl_app_heating_area_column = 5 # номер колонки (Площа опалювальна по КТЕ)
gl_counters_column = 6 # номер колонки (№ розподілювача)
gl_counters_k_priv_column = 15 # номер колонки (К приведене)
gl_counters_value1_column = 17 # номер колонки (показники на 01.12)
gl_counters_value2_column = 18 # номер колонки (показники на 01.11)
gl_ferst_app_row = 1 # номер ряда первого апартамента
gl_exl_shift_rows = 1 # количество рядов сдвига адреса в экселе от дата фрема в выдачи ошибки
# сдвиг строки от значения end для : по будинку за т/ліч
gl_shift_home_counter_value1 = 2
gl_shift_home_counter_value2 = 2
# колонки : по будинку за т/ліч
gl_column_home_counter_value1 = 17
gl_column_home_counter_value2 = 18
# *** report sheet:
# 0 № п/п 
gl_num_column = 0
# 1 № квартири  
gl_app_num_column = 1
# 2 Ітого по распр., Гкал
gl_total_couter_e_column = 2
# 3 Ітого по м2, Гкал
gl_total_no_couter_e_column = 3
# 4 функціонування системи
gl_func_sys_column = 4
# 5 МЗК
gl_mzk_column = 5
# 6 ВСЬОГО, Гкал
gl_total_e_column = 6
# ** report names:
gv_osbb_report = "ОСББ"
# ** osbb report setings:
gv_osbb_report = "ОСББ"
gv_enable_full_report = False
# gv_enable_full_report = True
# 0 № п/п 
gn_num_column = "№ п/п"
# 1 № квартири  
gn_app_num_column = "№ квартири"
# 2 Ітого по распр., Гкал
gn_total_couter_e_column = "Ітого по распр., Гкал"
# 3 Ітого по м2, Гкал
gn_total_no_couter_e_column = "Ітого по м2, Гкал"
# 4 функціонування системи
gn_func_sys_column = "функціонування системи"
# 5 МЗК
gn_mzk_column = "МЗК"
# 6 ВСЬОГО, Гкал
gn_total_e_column = "ВСЬОГО, Гкал"
# ** Теплоенрго report setings:
gv_TE_report_formar_len = "{:.3f}".format
gv_TE_report = "Теплоенрго"
# 0 Особовий рахунок  
gn_TE_num_column = "Особовий рахунок"
# 1 № Адреса  
gn_TE_adders_column = "Адреса"
# 2 № віртуального ліч-ка
gn_TE_num_virt_column = "№ віртуального ліч-ка"
# 3 Період
gn_TE_period = "Період"
# 4 Обсяг споживання,  Гкал
gn_TE_total_e_column = "Обсяг споживання,  Гкал"
# ** Rules list:
gr_rule_sheet_name = "Налаштування"
gr_rule_sheet_enable_in_report = True
gr_rule_tag = "rule"
gr_rule_name_col = 1
gr_rule_len_col = 2
gr_rule_params_start_col = 3

#+end_src
*** test_global_values.py
/home/buyn/Dev/Python/Sontex/Src/test_global_values.py
** integation test
*** ingtest01.py
:PROPERTIES:
:header-args: :tangle ../Src/ingtest01.py
:END:
**** src ingtest01.py
***** import block:
from main import *
#+begin_src python
import unittest
import sys
import os
import pandas as pd
from winmain import *
# (pyvenv-activate "sontex-env")


#+end_src
***** def load_exel:
#+begin_src python
def load_exel(filename, sheet_name): 
    return pd.read_excel( filename,
                          sheet_name = sheet_name,
                          engine='openpyxl',
                          # index_col=0,
                          header=None,)
#+end_src
***** class Test:
# ** ------------------------------------------:
#+begin_src python
class Test(unittest.TestCase):

#+end_src
***** def test_integ_initest:
  @unittest.skipIf(len(sys.argv) < 2  or sys.argv[1] != "ingtest01.Test.test_integ_initest", "not sigle test")
#+begin_src python
  def test_integ_initest(self):
      # sys.argv = ['', 'Test.testName']
      print(sys.argv)
      print(sys.argv[0])
      # print(sys.argv[1])
      # if sys.argv[1] == "ingtest01.Test.test_integ_initest": print("test found!!")
    

#+end_src
***** def test_run_winmai_calc_exel:
#+begin_src python
  def test_run_winmai_calc_exel(self):
    exel_path = "Data_files/test.xlsx"
    # csv_path = "Data_files/test.rlv"
    csv_path = None
    output_path = "Data_files/test_output.xlsx"
    # /home/buyn/Dev/Python/Sontex/Src/Data_files/output.xlsx
    home_counter = ""
    if os.path.exists(output_path):
      os.remove(output_path)

    self.assertFalse (os.path.exists(output_path), "Output file does exist")
    start_calc(exel_path, csv_path, output_path, home_counter)

    # Assert if the output file exists
    self.assertTrue(os.path.exists(output_path), "Output file does not exist")

    # gv_filename = "Data_files/test.xlsx"
    sheet_name = "Теплоенрго"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[1, 1], "кв.1")
    self.assertEqual(df_report.iloc[1, 4], 2.326)
    self.assertEqual(df_report.shape[0], 41)
    self.assertEqual(df_report.iloc[40, 4], 63.72)

    sheet_name = "квартири, площі"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[7, 1], "кв.7")
    # 8
    self.assertEqual(df_report.iloc[7, 18], 603)
    self.assertEqual(df_report.iloc[7, 17], 653)
    # 31
    self.assertEqual(df_report.iloc[30, 17], 445)
    self.assertEqual(df_report.iloc[30, 18], 437)
    self.assertEqual(df_report.shape[0], 141)
    self.assertEqual(df_report.iloc[109, 17], 1613.72)
    self.assertEqual(df_report.iloc[109, 18], 1550)


#+end_src
***** def test_run_winmai_calc_home:
#+begin_src python
  def test_run_winmai_calc_home(self):
    exel_path = "Data_files/test.xlsx"
    csv_path = ""
    # csv_path = "Data_files/test.rlv"
    # csv_path = "Data_files/test.csv"
    output_path = "Data_files/test_output.xlsx"
    # /home/buyn/Dev/Python/Sontex/Src/Data_files/output.xlsx
    home_counter = [100,0]
    if os.path.exists(output_path):
      os.remove(output_path)

    self.assertFalse (os.path.exists(output_path), "Output file does exist")
    start_calc(exel_path, csv_path, output_path, home_counter)

    # Assert if the output file exists
    self.assertTrue(os.path.exists(output_path), "Output file does not exist")

    # gv_filename = "Data_files/test.xlsx"
    sheet_name = "Теплоенрго"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[1, 1], "кв.1")
    self.assertEqual(df_report.iloc[1, 4], 3.65)
    self.assertEqual(df_report.shape[0], 41)
    self.assertEqual(df_report.iloc[40, 4], 100)

    sheet_name = "квартири, площі"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[7, 1], "кв.7")
    # 8
    self.assertEqual(df_report.iloc[7, 18], 603)
    self.assertEqual(df_report.iloc[7, 17], 653)
    # 31
    self.assertEqual(df_report.iloc[30, 17], 445)
    self.assertEqual(df_report.iloc[30, 18], 437)
    self.assertEqual(df_report.shape[0], 141)
    self.assertEqual(df_report.iloc[109, 17], 100)
    self.assertEqual(df_report.iloc[109, 18], 0)


#+end_src
***** def test_run_winmai_calc_rlv:
#+begin_src python
  def test_run_winmai_calc_rlv(self):
    exel_path = "Data_files/test.xlsx"
    # csv_path = ""
    csv_path = "Data_files/test.rlv"
    # csv_path = "Data_files/test.csv"
    output_path = "Data_files/test_output.xlsx"
    # /home/buyn/Dev/Python/Sontex/Src/Data_files/output.xlsx
    home_counter = None
    if os.path.exists(output_path):
      os.remove(output_path)

    self.assertFalse (os.path.exists(output_path), "Output file does exist")
    start_calc(exel_path, csv_path, output_path, home_counter)

    # Assert if the output file exists
    self.assertTrue(os.path.exists(output_path), "Output file does not exist")

    # gv_filename = "Data_files/test.xlsx"
    sheet_name = "Теплоенрго"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[1, 1], "кв.1")
    self.assertEqual(df_report.iloc[1, 4], 2.326)
    self.assertEqual(df_report.shape[0], 41)
    self.assertEqual(df_report.iloc[40, 4], 63.72)

    sheet_name = "квартири, площі"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[7, 1], "кв.7")
    # 8
    self.assertEqual(df_report.iloc[7, 18], 603)
    self.assertEqual(df_report.iloc[7, 17], 653)
    # 31
    self.assertEqual(df_report.iloc[30, 17], 195)
    self.assertEqual(df_report.iloc[30, 18], 437)
    self.assertEqual(df_report.shape[0], 141)
    self.assertEqual(df_report.iloc[109, 17], 1613.72)
    self.assertEqual(df_report.iloc[109, 18], 1550)


#+end_src
***** def test_run_winmai_calc_rlv_csv:
#+begin_src python
  def test_run_winmai_calc_rlv_csv(self):
    exel_path = "Data_files/test.xlsx"
    # csv_path = ""
    csv_path = "Data_files/test.rlv;Data_files/test.csv"
    # csv_path = "Data_files/test.csv"
    output_path = "Data_files/test_output.xlsx"
    # /home/buyn/Dev/Python/Sontex/Src/Data_files/output.xlsx
    home_counter = None
    if os.path.exists(output_path):
      os.remove(output_path)
    # Assert if the output file exists
    self.assertFalse (os.path.exists(output_path), "Output file does exist")
    start_calc(exel_path, csv_path, output_path, home_counter)
    # Assert if the output file not exists
    self.assertTrue(os.path.exists(output_path), "Output file does not exist")
    # gv_filename = "Data_files/test.xlsx"
    sheet_name = "Теплоенрго"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[1, 1], "кв.1")
    self.assertEqual(df_report.iloc[1, 4], 2.326)
    self.assertEqual(df_report.shape[0], 41)
    self.assertEqual(df_report.iloc[40, 4], 63.72)
    sheet_name = "квартири, площі"
    df_report = load_exel(output_path, sheet_name)
    # print(df_report)
    self.assertIsNotNone(df_report )
    self.assertEqual(df_report.iloc[7, 1], "кв.7")
    # 8
    self.assertEqual(df_report.iloc[7, 18], 603)
    self.assertEqual(df_report.iloc[7, 17], 126)
    # 31
    self.assertEqual(df_report.iloc[30, 17], 76)
    self.assertEqual(df_report.iloc[30, 18], 437)
    self.assertEqual(df_report.shape[0], 141)
    self.assertEqual(df_report.iloc[109, 17], 1613.72)
    self.assertEqual(df_report.iloc[109, 18], 1550)


#+end_src
***** Test runer:
# * Test runer : 
# ** ------------------------------------------:
# (compile " D:/Development/version-control/GitHub/Vadim/Tochil/main_test.py -k init")
# (compile " python -m unittest D:/Development/version-control/GitHub/Vadim/Tochil/main_test.py ")
# ** if __main__: 
    # runner = unittest.TextTestRunner()
    # runner.run(suite_Init())
    # sys.argv = ['', 'Test.testName']
    import sys
    print("args = ", sys.argv)
#+begin_src python
if __name__ == "__main__":
    print("args = ", sys.argv)
    unittest.main()
#+end_src
**** file
(find-file-other-frame "../Src/ingtest01.py")
**** run
***** compile
#+begin_src emacs-lisp :results output silent :tangle no
(pyvenv-activate "sontex-env")
(compile "python ../Src/ingtest01.py")
(find-file-other-frame "../Src/ingtest01.py")
#+end_src

source sontex-env/bin/activate
(compile "source sontex-env/bin/activate ; python -m sandbox")
#+begin_src emacs-lisp :results output silent :tangle no
(compile "source sontex-env/bin/activate ; python -m sandbox")
#+end_src
***** single test run
#+begin_src emacs-lisp :results output silent :tangle no
(pyvenv-activate "sontex-env")
(compile "python3 -m unittest ../Src/ingtest01.Test.test_integ_initest")
(find-file-other-frame "../Src/ingtest01.py")
#+end_src

** main
*** main.py
**** file
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/Src/main.py")
#+end_src

#+begin_src emacs-lisp :results output silent
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/main.py")
#+end_src
**** src main.py
:PROPERTIES:
:header-args: :tangle ../Src/main.py
:END:
***** all
#+begin_src python
# * imports :
# ----------------------------------------------
import sys
import pandas as pd
from global_values import *
from appart_values import *
from rules import *
import winmain as wm


# ----------------------------------------------
# * vars :
# ----------------------------------------------
g_filename = gv_filename
g_output = gv_output
g_sheet_name = gv_sheet_name
g_csv = gv_csv


# ----------------------------------------------
# * main:
# ** def cli : 
# ----------------------------------------------
def cli(argv): 
    filename, csv, sheet_name = cmd_line_arg(argv)
    sheet_name = g_sheet_name 
    filename = g_filename
    output = g_output
    csv = g_csv
    df = load_exel(filename, sheet_name)
    app_list, couters_list = populate_apps(df) 
    app_list = calc_all_values_in_apps( df, app_list)
    df_report = load_exel(filename, gv_sheet_report)
    df_report = set_to_report(df_report, app_list)
    save_data_frame(output, df, df_report)


# ----------------------------------------------
# ** def gui : 
# ----------------------------------------------
def gui(argv): 
    wm.winmain(argv)


# ----------------------------------------------
# ** def gui_calc : 
# ----------------------------------------------
def gui_calc(_filename, _csv, _output, _home_count = None): 
# *** set values and params :
    sheet_name = g_sheet_name 
    filename = g_sheet_name if not _filename or _filename == "" else _filename
    output =  _output if _output or _output != "" else g_output
# *** loading a dataframe from Excel :
    df = load_exel(filename, sheet_name)
    csv = ";" if not _csv or _csv == "" else _csv
    app_list, couters_list = populate_apps(df) 
    if _home_count:
        last_app_line = get_last_app_line(app_list)
        r = set_home_counter(df, last_app_line, _home_count)
        print(r)
        wm.print_to_log("Ці клітини загальнобудинкового лічильника використовуються, ігноруючи показники з клітини файлу Excel")
        wm.print_to_log("використання значення = "+ str(_home_count))
        wm.print_to_log(r)
# *** loading date frame from CSV or RLV file:
    udate_data = set()
    for path_csv in csv.split(";"):
        if path_csv=="":
            continue
        wm.print_to_log("завантажуємо значення з файлу: "+path_csv)
        udate_data.add(update_counters(app_list,
                                       couters_list,
                                       load_db(path_csv)))
    #  замена имени столбца
    df.iloc[gl_ferst_app_row - 1, gl_column_home_counter_value1] = "показники на " + ";".join(udate_data)
    # TODO: remove duble populate_apps
    app_list, couters_list = populate_apps(df) 

# *** product of calculations:
    app_list = calc_all_values_in_apps( df, app_list)
    # df_report = load_exel(filename, gv_sheet_report)
    # df_report = set_to_report(df_report, app_list)
# *** generating reports:
    df_report = None
    if gv_enable_full_report:
        df_report = gen_OSBB_report(app_list)
    df_TE_report = gen_TE_report(app_list)
# *** postprocessing block:
    # df_rules = load_exel(filename, gr_rule_sheet_name)
    try:
          df_rules = load_exel(filename, gr_rule_sheet_name)
          df_TE_report = postprocessing_df_with_rules_df(df_TE_report, df_rules)
    except Exception:
          df_rules = None
          print("Error in load rules sheet = ", gr_rule_sheet_name ," from file =", filename)
          wm.print_to_log("Помилка під час завантаження аркуша правил = "+ gr_rule_sheet_name + " з файлу =" + filename)
    if not gr_rule_sheet_enable_in_report:
        df_rules = None
# *** save block:
    save_data_frame(output, df,
                    df_report,
                    df_rules = df_rules,
                    df_TE_report = df_TE_report)


# ----------------------------------------------
# ** def main(argv):
# ----------------------------------------------
def main(argv):
    if gg_GUI and not is_test(argv):
        gui(argv) 
    else:
        cli(argv) 
    end_app(0)


# ----------------------------------------------
# ** end_app(arg):
def end_app(arg):
    sys.exit(arg)

    
# * line arg functions:
# ----------------------------------------------
# ** cmd_line_arg:
# ----------------------------------------------
def cmd_line_arg(argv):
    global g_filename, g_csv, g_output
    for arg in argv[1:]:
        if arg.startswith("--filename="):
            g_filename = arg.split("=")[1]
        if arg.startswith("--csv="):
            g_csv = arg.split("=")[1]
        if arg.startswith("--output="):
            g_output = arg.split("=")[1]
        if arg.startswith("--sheet_name="):
            sheet_name = arg.split("=")[1]
        # else:
        #     if arg.find("\\") != -1:
        #         print("is windows path")
        #         arg = arg.replace("\\", "/")
        #     if not os.path.exists(arg):
        #         print("File not exists: ", arg)
        #         sys.exit()
        #     # print("file found")
        #     gv_filename = arg
    return g_filename, g_csv, g_output


# ----------------------------------------------
# ** def is_test:
# ----------------------------------------------
def is_test(argv): 
    for arg in argv[1:]:
        if arg.startswith("--test"):
            return True
    return False


# ----------------------------------------------
# ** ------------------------------------------:
# * calc functions:
# ----------------------------------------------
# ** def gen_sum_heated_area :
def gen_sum_heated_area(apps): 
    # Площа опалювальна по КТЕ
    return sum([app.heating_area for app in apps])


# ** def sum_E_used_k :
def sum_E_used_k(apps): 
    #сумма сумарне приведене споживання по квартирі, од.
    return sum([app.gen_E_used_k() for app in apps])


# ** def gen_no_counter_sum_area :
def gen_no_counter_sum_area(apps): 
    # площа без розп
    # по Площа опалювальна по КТЕ
    return sum([app.heating_area for app in apps if not app.counters_list])


# ** def get_last_app_line : 
def get_last_app_line(apps): 
    if apps[-1].is_last :
      return apps[-1].next_app_line
    else:
      wm.print_to_log('Помилка у вхідному файлі Excel get_last_line не в останній квартирі ' + str(len(apps)))
      raise NameError(
          'get_last_line in not last appart ' + str(len(apps)))


# ** def get_home_value : 
def get_home_value(df, line, column):
    # r =  float(df.iloc[line, column])
    r =  df.iloc[line, column]
    # print("value = ", r)
    if not isinstance(r, float) and not isinstance(r, int):
        wm.print_to_log('Помилка у вхідному Excel файлі: не числовий формат показника у клітини in get_home_value not int or float on line = ' + str(line + gl_exl_shift_rows) + ', for column ' + str(column))
        raise NameError('in get_home_value not int or float on line = ' + str(line + gl_exl_shift_rows) + ', for column ' + str(column))
    if pd.isna(r):
        wm.print_to_log('Помилка у вхідному Excel файлі: у клітини відсутнє значення no value on line = ' + str(line + gl_exl_shift_rows) + ', for column ' + str(column))
        raise NameError('no value on line = ' + str(line + gl_exl_shift_rows) + ', for column ' + str(column))
    return r
    

# ** def set_home_counter : 
def set_home_counter(df, g_line, values): 
    if not values or values[0] == "" and values[1] == "":
        return "значення загальнобудинкового лічильника використані з Excel"
    if values[0] != "":
      df.iloc[g_line + gl_shift_home_counter_value1, gl_column_home_counter_value1] = float(values[0])
    if values[1] != "":
      df.iloc[g_line + gl_shift_home_counter_value2, gl_column_home_counter_value2] = float(values[1])
    return "значення загальнобудинкового лічильника в екселі оновлено" + str(values[0]) + " ; " + str(values[0])
    

# ** def gen_delta_value_home_counter : 
def gen_delta_value_home_counter(df, g_line): 
    return get_home_value(df,
                g_line + gl_shift_home_counter_value1,
                gl_column_home_counter_value1) - get_home_value(df,
                    g_line + gl_shift_home_counter_value2,
                    gl_column_home_counter_value2)
    

# ** def gen_Qfun_sys : 
def gen_Qfun_sys(delta_value_home_counter): 
    # обсяг тепла на функц. системи = 5% якщо є погодне регулювання в ІТП або 15% якщо не має від
    return delta_value_home_counter * gk_Qfun_sys


# ** def gen_Qmzk : 
def gen_Qmzk(delta_value_home_counter): 
    # обсяг тепла на опалення МЗК = 10% від
    return delta_value_home_counter * gk_Qmzk


# ** def gen_Qroz : 
def gen_Qroz(delta_value_home_counter, sum_heated_area): 
    # Питомий обсяг спожитої енергії на опалення усіх приміщень
    return (delta_value_home_counter
            - gen_Qfun_sys(delta_value_home_counter)
            - gen_Qmzk(delta_value_home_counter)) / sum_heated_area


# ** def gen_Qop_min : 
def gen_Qop_min(q_roz): 
    # Мінімальна частка середнього питомого споживання
    # gk_Qop_min_after_point
    # количество знаков после запятой для этой переменой
    # при повышение точности в этой переменой разница силльно растёт
    # False для максимальной точности
    # True для
    # 3 значения соответствуюшее екселю
    r = gk_Qop_min * q_roz
    if gk_Qop_min_after_point:
        r = float("{:.3f}".format(r))
    return r

# ** def gen_Qpit_roz : 
def gen_Qpit_roz(sum_home_e, qfun_sys, q_Mkz, sum_no_counter_e): 
    """
    питомий обсяг енергії спожитий одним розподілювачем
    Обсяг споживання тепла з розподілювачами
    """
    return sum_home_e - qfun_sys - q_Mkz - sum_no_counter_e

      
# ** def calc_surcharge : 
def calc_surcharge(app_list, q_pit_roz, q_op_min): 
    sum_e_k = sum_E_used_k(app_list)
    if sum_e_k == 0:
      wm.print_to_log('Помилка: сумарне використання енергії 0, нема нічого для обчислення no Energi use in any appartament (exempl colmn R = colmn S)')
      raise ValueError('no Energi use in any appartament (exempl colmn R = colmn S)')
    for i, app in enumerate(app_list):
        app_list[i].gen_surcharge(q_pit_roz, q_op_min, sum_e_k)
        # print("in ", app_list[i]._start_line )
        # print("index ", i)
        # print("value of ", app_list[i].surcharge)
    return gen_e_for_redistribute(app_list)


# ** def recalc_surcharge : 
def recalc_surcharge(app_list,
                     q_op_min,
                     e_for_redistibut,
                     times =gs_recalc_surcharge_times) : 
    start_times = times
    if gs_recalc_surcharge_print:
        print(start_times - times +1, ":e_for_redistibut = ", e_for_redistibut)
        print(start_times - times +1, ":suM surcharge = ", sum([app.surcharge for app in app_list]))
    # while times>=0 and e_for_redistibut >= 0:
    while times>0 and float("{:.5f}".format(sum([app.surcharge for app in app_list]))) != 0:
    # TODO chenge to compare with 0.000001 it help add this to setings
    # while times>0 and sum([app.surcharge for app in app_list]) != 0:
        for i, app in enumerate(app_list):
            # print("in ", app_list[i]._start_line )
            # print("index ", i)
            app_list[i].gen_specified_used_E (e_for_redistibut)
            app_list[i].gen_specified_surcharge(q_op_min)
            # print("value of 0 ", app_list[0].surcharge)
        # питомий обсяг енергій якій буде перерозподілено
        e_for_redistibut = gen_e_for_redistribute(app_list)
        times -=1
        if gs_recalc_surcharge_print:
            print(start_times - times +1, ":e_for_redistibut = ", e_for_redistibut)
            print(start_times - times +1, ":suM surcharge = ", sum([app.surcharge for app in app_list]))  # 
    if gs_recalc_surcharge_print_result:
        print("Zero recalculate surcharge found on step =", start_times - times +1)
    return e_for_redistibut


# ** def gen_e_for_redistribute : 
def gen_e_for_redistribute(app_list): 
    # обсяг енергій якій буде перерозподілено
    sum_E = sum([app.surcharge for app in app_list])
    # площа квартир якім буде повернуто об'єм донарахувань
    sum_S = sum([app.get_S_if_surcharge() for app in app_list])
    # питомий обсяг енергій якій буде перерозподілено
    return sum_E/sum_S



# ** def gen_total_counter_e : 
def gen_total_counter_e(apps): 
    """
    sum Ітого по распр., Гкал
    """
    return sum([app.specified_used_E for app in apps if app.counters_list])


# ** def gen_total_no_counter_e : 
def gen_total_no_counter_e(apps): 
    """
    sum Ітого по м2, Гкал
    """
    return sum([app.specified_used_E for app in apps if not app.counters_list])


# ** def gen_Q_no_surge : 
def gen_Q_no_surge(app_list, q_roz): 
    """
    при цьому питомий обсяг споживання тепла приміщеннями без розподілювачів 
    """
    return ( gen_k_no_surge(app_list)
             * q_roz)


# ** def gen_k_no_surge : 
def gen_k_no_surge(apps): 
    return  qk_k_no_surge_if_less if gen_no_counter_sum_area(apps) / gen_sum_heated_area(apps) < qk_k_no_surge_proc else qk_k_no_surge_if_more 

    
# ** def calc_no_counter_e : 
def calc_no_counter_e( app_list,
                       q_no_surge): 
    """
    generate in app list
    by use metod of clas
    app_list[i].gen_no_counter_e(q_no_surge)
    Ітого по м2, Гкал
    """
    for i, app in enumerate(app_list):
        # print("in ", app_list[i]._start_line )
        # print("index ", i)
        if not app.counters_list:
          app_list[i].gen_no_counter_e (q_no_surge)
          # print(app_list[i].specified_used_E) 
    return app_list




# ** def calc_final_totals : 
def calc_final_totals(app_list,
                      qfun_sys,
                      q_Mkz,
                      sum_heated_area): 
    s_qfun_sys = qfun_sys / sum_heated_area
    # print(s_qfun_sys)
    s_q_Mkz = q_Mkz / sum_heated_area
    # print(s_q_Mkz)
    for i, app in enumerate(app_list):
        # print("in ", app_list[i]._start_line )
        # print("index ", i)
        # функціонування системи
        app_list[i].gen_total_fun_sys (s_qfun_sys)
        # МЗК
        app_list[i].gen_total_Mkz (s_q_Mkz)
        # ВСЬОГО, Гкал
        app_list[i].gen_total_e()
    return app_list




# ** def calc_all_values_in_apps : 
def calc_all_values_in_apps(df, app_list): 
    # загальна площа будинку
    sum_heated_area = gen_sum_heated_area(app_list)
    last_app_line = get_last_app_line(app_list)
    # по будинку за т/ліч
    delta_value_home_counter = gen_delta_value_home_counter(df, last_app_line)
    # Питомий обсяг спожитої енергії на опалення усіх приміщень
    q_roz = gen_Qroz(delta_value_home_counter, sum_heated_area)
    # обсяг тепла на опалення МЗК = 10% від
    q_Mzk = gen_Qmzk(delta_value_home_counter)
    # обсяг тепла на функц. системи = 5% якщо є погодне регулювання в ІТП або 15% якщо не має від
    qfun_sys = gen_Qfun_sys(delta_value_home_counter)
    # Обсяг споживання тепла приміщенням без розподілювачамиів
    q_no_surge = gen_Q_no_surge(app_list,
                                q_roz)
    # calculate column in app_list
    # Ітого по м2, Гкал
    app_list = calc_no_counter_e( app_list,
                       q_no_surge)
    # sum Ітого по м2, Гкал
    total_no_counter_e = gen_total_no_counter_e(app_list)
    # питомий обсяг енергії спожитий одним розподілювачем
    q_pit_roz = gen_Qpit_roz(delta_value_home_counter, qfun_sys, q_Mzk, total_no_counter_e)
    q_op_min = gen_Qop_min(q_roz)
    # донарахування, Гкал
    # in each counter
    # return 
    # питомий обсяг енергій якій буде перерозподілено
    e_for_redistibut = calc_surcharge(app_list,
                                      q_pit_roz,
                                      q_op_min)
    e_for_redistibut = recalc_surcharge(app_list,
                                        q_op_min,
                                        e_for_redistibut)
    # Ітого по распр., Гкал
    # total_counter_e = gen_total_counter_e(app_list)
    # calculate columns in app_list
    # функціонування системи
    # МЗК
    # ВСЬОГО, Гкал
    calc_final_totals( app_list,
                       gen_Qfun_sys(delta_value_home_counter),
                       q_Mzk,
                       sum_heated_area)
    return app_list


# ** ------------------------------------------:
# * file functions:
# ----------------------------------------------
# ** def load_exel : 
# ----------------------------------------------
def load_exel(filename, sheet_name): 
    df = pd.read_excel(filename,
                      sheet_name = sheet_name,
                      engine='openpyxl',
                      # index_col=0,
                      header=None,
                      )
    return df


# ** def load_csv : 
# ----------------------------------------------
def load_csv(filename): 
    if not filename:
        return None
    wm.print_to_log("Завантажуємо файл csv")
    df = pd.read_csv(filename ,
                    encoding = gv_csv_encoding,
                    header = gv_csv_header,
                    sep = gv_csv_sep,
                     index_col = gv_csv_index_col)
    wm.print_to_log("Файл csv завантажений")
    return df


# ** def load_rlv : 
def load_rlv(filename): 
    if not filename:
        return None
    wm.print_to_log("Завантажуємо файл rlv")
    df = pd.read_csv(filename ,
                    encoding = gv_rlv_encoding,
                    header = gv_rlv_header,
                    sep = gv_rlv_sep,
                     index_col = gv_rlv_index_col)
    wm.print_to_log("файл rlv завантажений")
    return df


# ** def load_db : 
def load_db(filename): 
    if not filename:
        return None
    extesion = (filename.split("."))[-1]
    if extesion == "rlv":
      return load_rlv(filename)
    elif extesion == "csv":
      return load_csv(filename)
    wm.print_to_log("Неприпустиме розширення файлу для оновлення. очікується .rlv або .csv. Файл проігноровано = "+ filename)
    return None


# ** del it def set_to_report : 
def set_to_report(df, app_list): 
    # 0 № п/п 
    # 1 № квартири  
    for app in app_list:
        if app.counters_list:
            # 2 Ітого по распр., Гкал
            app.set_to_report(df, gl_total_couter_e_column, app.specified_used_E)
        else:    
            # 3 Ітого по м2, Гкал
            app.set_to_report(df, gl_total_no_couter_e_column, app.specified_used_E)
        # 4 функціонування системи
        app.set_to_report(df, gl_func_sys_column, app.total_fun_sys)
        # 5 МЗК
        app.set_to_report(df, gl_mzk_column, app.total_Mkz)
        # 6 ВСЬОГО, Гкал
        app.set_to_report(df, gl_total_e_column, app.total_e)
    return df


# ** def gen_OSBB_
def gen_OSBB_report(app_list): 
    df = [[gn_num_column,
           gn_app_num_column,
           gn_total_couter_e_column, 
           gn_total_no_couter_e_column,
           gn_func_sys_column ,
           gn_mzk_column ,
           gn_total_e_column ]]
    for app in app_list:
        # 0 № п/п 
        # 1 № квартири  
        row =[app.num_name, app.app_num_name,]
        if app.counters_list:
            # 2 Ітого по распр., Гкал
            row.append(app.specified_used_E)
            row.append(0)
        else:    
            # 3 Ітого по м2, Гкал
            row.append(0)
            row.append(app.specified_used_E)
        # 4 функціонування системи
        row.append(app.total_fun_sys)
        # 5 МЗК
        row.append(app.total_Mkz)
        # 6 ВСЬОГО, Гкал
        row.append(app.total_e)
        df.append(row)
    return pd.DataFrame(df)


# ** def gen_TE_report:
def gen_TE_report(app_list): 
    df = [[
        # 0 Особовий рахунок  
        gn_TE_num_column,
        # 1 № Адреса  
        gn_TE_adders_column ,
        # 2 № віртуального ліч-ка
        gn_TE_num_virt_column ,
        # 3 Період
        gn_TE_period ,
        # 4 Обсяг споживання,  Гкал
        gn_TE_total_e_column ]]
    sum_total = 0
    for app in app_list:
        row =[
            # 0 № п/п 
            app.num_name,
            # 1 № квартири  
            app.app_num_name,
            # 2 № віртуального ліч-ка
            app.num_name]
        # 3 Період
        row.append("")
        # 4 Обсяг споживання,  Гкал
        # row.append(app.total_e)
        # row.append(float(gv_TE_report_formar_len.format(app.total_e)))
        row.append(float(gv_TE_report_formar_len(app.total_e)))
        df.append(row)
        sum_total += app.total_e
    df.append([])
    df.append([
        "", "", "","Всього:",
        (float(gv_TE_report_formar_len(sum_total)))
        # sum_total
    ])
    return pd.DataFrame(df)


# ** def save_data_frame:
def save_data_frame(output, df, df_report, df_rules=None, df_TE_report=None): 
  # Save the updated dataframe to the Excel file
  with pd.ExcelWriter(output,
                    # sheet_name='report',
                    engine='openpyxl',
                    # index_col=0,
                    # header=None,
                    # mode="a",
                    # if_sheet_exists="overlay"
                    # if_sheet_exists="replace"
                    # if_sheet_exists='append'
                      ) as writer:
    df.to_excel(writer, index=False, header=False, sheet_name=gv_sheet_name)
    if df_rules is not None:
        df_rules.to_excel(writer, index=False, header=False, sheet_name=gr_rule_sheet_name)
    if df_report is not None:
        df_report.to_excel(writer, index=False, header=False, sheet_name=gv_osbb_report)
    if df_TE_report is not None:
        df_TE_report.to_excel(writer, index=False, header=False, sheet_name=gv_TE_report)
    wm.print_to_log("output report path "+ output)


# ** def populate_apps:
def populate_apps(df): 
    al =[]
    cl =[]
    app_line = gl_ferst_app_row
    while True:
        app = Appart_values(df, app_line)
        app_line = app.next_app_line
        # print("app_line = ", app_line)
        al.append(app)
        cl.append(app.gen_counters_adress())
        if app.is_last:
            break
    return al, cl


# ** def update_counters:
def update_counters(app_list, counters_list, df_csv, data_i = 1): 
    if df_csv is None:
        return None
    name_date = gv_csv_name_date + str(gv_csv_name_i)
    # print(name_date)
    name_value = gv_csv_name_value + str(gv_csv_name_i)
    # print(name_value)
    data_list =set()
    id_list =set()
    for i, adress_list in enumerate(counters_list):
        if counters_list[i]:
            r = app_list[i].update_allvalues1_by_id(df_csv,  name_value, name_date)
            if r:
                data_list.update(r)
            else:
                id_list.update(app_list[i].not_found_ids)
                app_list[i].not_found_ids.clear()
            # print("data_ r = ", r) 
            # print("data_list = ", data_list) 
    # print("values", len(data_list))
    if len(data_list)==0:
        wm.print_to_log("помилка даних csv. Файл не містить жодного ID з exel")
        # print("ошибка даных csv. фаил не содержит не одного ID из exel ")
        wm.print_to_log("csv зіпсований. Обробку зупинено")
        raise NameError("csv corupt. no id exels in csv file ", "len(data_list) = ", len(data_list) )
    if len(data_list)!=1:
        for data in data_list:
          wm.print_to_log("помилка даних csv. Більше однієї дати у стовпці "+ name_date+ " = "+ data)
          print("помилка даних csv. Більше однієї дати у стовпці "+ name_date+ " = "+ data)
        # wm.print_to_log("csv uспорчен. Обработка остановлена")
        wm.print_to_log("csv зіпсований. Обробку не зупинено")
        data_list = data_list.pop();
        wm.print_to_log("назва стовбчика змінено на = " + str(data_list))
        # raise NameError("csv corupt. more then one date in csv column ", name_date, "len(data_list) = ", len(data_list) )
    # print("values from csv add on dates = ", data_list)
    if len(id_list)>0:
        wm.print_to_log("Ці ID вказані у файлі, але відсутні у Excel" + str(id_list))
    wm.print_to_log("Показники csv зафіксовані на дату"+ str(data_list))
    return str(data_list)


# ** ------------------------------------------:

# * if __name__ : 
# ----------------------------------------------
if __name__ == "__main__": 
    import sys
    # sys.argv = ['', 'Test.testName']
    main(sys.argv)


# ----------------------------------------------

#+end_src

*** test_main.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/Src/test_main.py")
#+end_src
** winmain
*** winmain.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/Src/winmain.py")
#+end_src
*** test_winmain.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/Src/test_winmain.py")
#+end_src
** appart_values
*** appart_values.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/Src/appart_values.py")
#+end_src
*** test_appart_values.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/test_appart_values.py")
#+end_src
** counter_values
*** counter_values.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/Src/counter_values.py")
#+end_src
*** test_counter_values.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/test_counter_values.py")
#+end_src
** rules
*** rules.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "/home/buyn/Dev/Python/Sontex/Src/rules.py")
#+end_src
*** test_rules.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "/home/buyn/Dev/Python/Sontex/Src/test_rules.py")
#+end_src
** .projectile
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/.projectile")
#+end_src
* sandbox
** sandbox.org
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "../Src/sandbox.org")
#+end_src

(find-file-other-frame "D:/Development/version-control/GitHub/Zmei/Sontex/Src/sandbox.org")
** sandbox.py
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "../Src/sandbox.py")
#+end_src
* scripts
:PROPERTIES:
:header-args: :dir ../Src/ :shebang #!/bin/bash  :tangle-mode (identity #o755) :tangle no
:END:
** start
*** search
#+HEADER: :tangle ../Src/Start.sh
#+begin_src sh 
source sontex-env/bin/activate
python main.py
#+end_src

** test all
*** win
@echo off
:start
python -m unittest
pause
cls
goto :start
*** sh
# python main.py
#+HEADER: :tangle ../Src/test_all.sh
#+begin_src sh 
clear
source sontex-env/bin/activate
# @echo off
while true; do
  python -m unittest
  echo "Press any key to run tests again or Ctrl+C to exit..."
  read -n 1 -s
  clear
done
#+end_src
** integr test
*** sh
# python main.py
#+HEADER: :tangle ../Src/test_integr.sh
#+begin_src sh 
clear
source sontex-env/bin/activate
# @echo off
while true; do
  # python -m unittest
  python3 -m unittest ingtest01
  python3 -m unittest test_winmain.Test_Init 
  python3 -m unittest test_winmain.Test_Init.test_btn_ask_open_exel_file 
  python3 -m unittest test_winmain.Test_Init.test_btn_ask_open_DBfiles 
  python3 -m unittest test_winmain.Test_Init.test_btn_asksaveasfile
  echo "Press any key to run tests again or Ctrl+C to exit..."
  read -n 1 -s
  clear
done
#+end_src
* arhiv
* Commands
:PROPERTIES:
:header-args: :tangle  no
:END:
** execute-src-block:
(save-excursion (progn (org-babel-goto-named-src-block "auto-tangle-block") (org-babel-execute-src-block)))
(save-excursion (let () (org-babel-goto-named-src-block "auto-tangle-block") (org-babel-execute-src-block)))
and then name the block you want to execute automatically:

** find-file:
[[elisp:(org-babel-tangle)]]
(find-file-other-frame "D:/Development/version-control/GitHub/my-python/pytts2d/SRC/MouseHandler.py")
(org-babel-tangle)
"D:\Development\version-control\GitHub\My-python\pytts2d\DOCs\Brain\MouseHandler.py control Class org.org" 

** evormnt
python -m venv prime-env

source sontex-env/bin/activate

pip install eel
pip install openpyxl

pip install numpy 
pip install matplotlib
pip install numpy matplotlib
** compile
#+begin_src emacs-lisp :results output silent :tangle no
(pyvenv-activate "sontex-env")
(compile "python -m sandbox")
#+end_src
(read-string
                    (concat
                      "defult(" (buffer-name) "):")
                    (buffer-file-name)
                    nil
                    (buffer-name))

source sontex-env/bin/activate

(compile "source sontex-env/bin/activate ; python -m sandbox")
#+begin_src emacs-lisp :results output silent :tangle no
(compile "source sontex-env/bin/activate ; python -m sandbox")
#+end_src

** auto-tangle-block:
#+NAME: auto-tangle-block
#+begin_src emacs-lisp :results output silent :tangle no
(setq org-src-preserve-indentation t)
(untabify (point-min) (point-max))
;; (save-buffer)
(save-some-buffers 'no-confirm)
;; (universal-argument)
;; (universal-argument)
(org-babel-tangle)
;; (save-buffer)
;; (save-some-buffers 'no-confirm)
(org-save-all-org-buffers)
(evil-normal-state)
(let ((curent-buffer (buffer-name)))
  (select-frame-by-name "*compilation*")
  (recompile)
  (select-frame-by-name curent-buffer))
(evil-close-fold)

;; (find-file-other-frame "~/INI/babel-cfg.el")
;; (load "~/INI/hydra-cfg.el")
;; (load "~/ELs/BuYn/reader.el")
 #+end_src
*** CANCELED arhiv
CLOSED: [2025-04-02 Wed 18:52]
#+begin_src emacs-lisp :results output silent :tangle no
(setq org-src-preserve-indentation t)
(untabify (point-min) (point-max))
(save-some-buffers 'no-confirm)
;; (save-buffer)
(org-babel-tangle)
(find-file-other-frame "sandbox.py")
(recompile)
;; (load "~/INI/hydra-cfg.el")
;; (load "~/ELs/BuYn/reader.el")
#+end_src

** keys
*** org-mode-map (kbd "<f8>
#+begin_src elisp tangle no
;;  --------------------------------------
(define-key org-mode-map (kbd "<f8>") nil)
(define-key org-mode-map (kbd "<f8> <f8>") '(lambda() (interactive)
        (save-excursion
          (progn
            (org-babel-goto-named-src-block "auto-tangle-block")
            (org-babel-execute-src-block)))
                                ))
;; --------------------------------------
#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (save-excursion (progn (org-babel-goto-named-src-block auto-tangle-block) (org-babel-execute-src-block))) |

* 2024-09-06
** Sontex.org
D:\Development\lisp\Dropbox\Office\Progects\Zmei 
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dropbox/Office/Progects/Zmei/Sontex/Sontex.org")
#+end_src

** main.org
#+begin_src emacs-lisp :results output silent
(find-file-other-frame "~/Dev/Python/Sontex/DOCs/main.org")
#+end_src
